"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useStackedPages = exports.useStackedPagesProvider = void 0;
const react_1 = require("react");
const gatsby_1 = require("gatsby");
const querystring_1 = __importDefault(require("querystring"));
const lodash_throttle_1 = __importDefault(require("lodash.throttle"));
const contexts_1 = require("./contexts");
const throttleTime = 16;
const obstructedOffset = 120;
function useScroll() {
    const containerRef = react_1.useRef(null);
    const [scroll, setScroll] = react_1.useState(0);
    const [width, setWidth] = react_1.useState(0);
    const scrollObserver = react_1.useCallback(() => {
        if (!containerRef.current) {
            return;
        }
        setScroll(containerRef.current.scrollLeft);
        setWidth(containerRef.current.getBoundingClientRect().width);
    }, [setScroll, setWidth, containerRef]);
    const throttledScrollObserver = lodash_throttle_1.default(scrollObserver, throttleTime);
    const setRef = react_1.useCallback((node) => {
        if (node) {
            // When the ref is first set (after mounting)
            node.addEventListener("scroll", throttledScrollObserver);
            containerRef.current = node;
            window.addEventListener("resize", throttledScrollObserver);
            throttledScrollObserver(); // initialization
        }
        else if (containerRef.current) {
            // When unmounting
            containerRef.current.removeEventListener("scroll", throttledScrollObserver);
            window.removeEventListener("resize", throttledScrollObserver);
        }
    }, []);
    return [scroll, width, setRef, containerRef];
}
function useStackedPagesProvider({ location, processPageQuery, firstPageSlug, pageWidth = 625, }) {
    const [scroll, containerWidth, setRef, containerRef] = useScroll();
    const [stackedPages, setStackedPages] = react_1.useState([]);
    const [stackedPageStates, setStackedPageStates] = react_1.useState({});
    const stackedPagesSlugs = react_1.useMemo(() => {
        const res = querystring_1.default.parse(location.search.replace(/^\?/, "")).stackedPages || [];
        if (typeof res === "string") {
            return [res];
        }
        return res;
    }, [location]);
    react_1.useEffect(() => {
        if (!window.___loader) {
            throw new Error("`react-stacked-pages-hook` can only be used with Gatsby");
        }
        Promise.all(
        // hook into the internals of Gatsby to dynamically fetch the notes
        stackedPagesSlugs.map((slug) => window.___loader.loadPage(slug))).then((data) => setStackedPages(
        // filter out 404s
        data
            .map((x, i) => ({
            slug: stackedPagesSlugs[i],
            data: processPageQuery ? processPageQuery(x) : x,
        }))
            .filter((x) => x.data)));
    }, [stackedPagesSlugs]);
    react_1.useEffect(() => {
        if (containerRef.current) {
            containerRef.current.scrollTo({
                top: 0,
                left: pageWidth * (stackedPages.length + 1),
                behavior: "smooth",
            });
        }
    }, [stackedPages, containerRef]);
    react_1.useEffect(() => {
        const acc = firstPageSlug
            ? {
                [firstPageSlug]: {
                    overlay: false,
                    obstructed: scroll > pageWidth - obstructedOffset,
                },
            }
            : {};
        if (!containerRef.current) {
            setStackedPageStates(stackedPages.reduce((prev, x) => {
                prev[x.slug] = {
                    overlay: true,
                    obstructed: false,
                };
                return prev;
            }, acc));
            return;
        }
        setStackedPageStates(stackedPages.reduce((prev, x, i) => {
            prev[x.slug] = {
                overlay: scroll > pageWidth * i - (40 * i - 1) ||
                    scroll < pageWidth * (i - 1),
                obstructed: scroll > pageWidth * (i + 2) - obstructedOffset ||
                    scroll + containerWidth < pageWidth * (i + 1) + obstructedOffset,
            };
            return prev;
        }, acc));
    }, [stackedPages, containerRef, scroll, setStackedPageStates]);
    const navigateToStackedPage = react_1.useCallback((to, index) => {
        let existingPage = stackedPages.findIndex((x) => x.slug === to);
        if (existingPage === -1) {
            if (to === firstPageSlug) {
                existingPage = 0;
            }
        }
        else {
            existingPage += 1;
        }
        if (existingPage !== -1 && containerRef && containerRef.current) {
            containerRef.current.scrollTo({
                top: 0,
                left: pageWidth * existingPage,
                behavior: "smooth",
            });
            return;
        }
        const search = querystring_1.default.parse(window.location.search.replace(/^\?/, ""));
        search.stackedPages = stackedPages
            .slice(0, index)
            .map((x) => x.slug)
            .concat(to);
        gatsby_1.navigate(`${window.location.pathname.replace(gatsby_1.withPrefix(""), "")}?${querystring_1.default.stringify(search)}`);
    }, [stackedPages]);
    return [
        stackedPages,
        stackedPageStates,
        navigateToStackedPage,
        contexts_1.StackedPagesContext.Provider,
        contexts_1.StackedPagesIndexContext.Provider,
        setRef,
    ];
}
exports.useStackedPagesProvider = useStackedPagesProvider;
function useStackedPages() {
    const { stackedPages, navigateToStackedPage } = react_1.useContext(contexts_1.StackedPagesContext);
    const index = react_1.useContext(contexts_1.StackedPagesIndexContext);
    const hookedNavigateToStackedPage = react_1.useCallback((to) => navigateToStackedPage(to, index), [navigateToStackedPage, index]);
    return [stackedPages, hookedNavigateToStackedPage, index];
}
exports.useStackedPages = useStackedPages;
